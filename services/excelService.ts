import * as XLSX from 'xlsx';
import { ColumnConfig } from '../types';

export const readExcel = async (file: File): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = e.target?.result;
        const workbook = XLSX.read(data, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        
        // Clean data: Remove keys generated by empty headers (e.g. __EMPTY)
        const cleanedData = jsonData.map((row: any) => {
            const newRow: any = {};
            Object.keys(row).forEach(key => {
                // Filter out internal Excel keys or empty headers
                if (!key.startsWith('__EMPTY')) {
                    newRow[key] = row[key];
                }
            });
            return newRow;
        });

        resolve(cleanedData);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = (error) => reject(error);
    reader.readAsBinaryString(file);
  });
};

export const exportExcel = (data: any[], columns: ColumnConfig[], filename: string = 'export.xlsx') => {
  // Map data back to original headers for export logic if needed, 
  // currently we export with the keys present in data.
  // To strictly follow original format, we might map keys back.
  
  const exportData = data.map(row => {
    const newRow: any = {};
    columns.forEach(col => {
      // We map the potentially edited value back to the ORIGINAL header name
      // This ensures the exported file structure matches the input file structure
      newRow[col.originalHeader] = row[col.originalHeader];
    });
    return newRow;
  });

  const worksheet = XLSX.utils.json_to_sheet(exportData);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
  XLSX.writeFile(workbook, filename);
};